#include "esphome.h"
#include <bitset>
#include <string>

class HamulightRemoteAdvanced : public Component, public LightOutput {
 private:
   uint8_t RFaddress[] = { 0xC5, 0x35 };     // change the address as needed to match your physical remote

   // DO NOT CHANGE THE FOLLOWING BYTES unless you know what exactly you are doing
   uint8_t RFpower         = 0x5F;                                  // power toggle command
   uint8_t RFbright100     = 0x59;                                  // 100% brightness command + command for training the transformator/receiver
   uint8_t RFbright75      = 0x50;                                  //  75% brightness command
   uint8_t RFbright50      = 0x56;                                  //  50% brightness command
   uint8_t RFbright25      = 0x55;                                  //  25% brightness command
   uint8_t RFslideRangeMin = 0x80;                                  // lowest HEX value used by dimm slider
   uint8_t RFslideRangeMax = 0xFF;                                  // highest HEX value used by dimm slider
   uint8_t RFslideOffset   = 0xA8;						                   		// needed for the offset in the slideValConv() function
   uint8_t RFslideSteps    = RFslideRangeMax - RFslideRangeMin + 1;	// steps from 0% to 100% dimm value
   uint8_t RFslideStart    = RFslideRangeMin + RFslideOffset;	  		// is the 0% dimm value position

   // --- RF PROTOCOL - RADIO SIGNAL PATTERNS ---
   // You can define your RF protocol below. Current approach is that one bit is always a HIGH followed by a LOW in the duration
   // of a specific length each.
   // First you need to know the smallest common divisor of all pulse lengths and define it in micro secongs below. (e.g. 200 uS)
   // Second you need to define the Bits based on their HIGH/LOW durations (e.g. { 3, 1 } would be 3x 200uS = 600uS HIGH followed
   // by 1x 200uS = 200uS LOW
   // The sync sequence and start bit is to be defined in the array startSequence below. The reading is the same as for the bit
   // arrays, but a little longer to allow more complex codes. IMPORTANT: The array itself begins with the first high. Just enter
   // a leading 0 in case your sequence starts with with a LOW.
   // To allow even more complex protocols the code may be extended by an endSequence variable. If done so, the functions need to
   // be extended accordingly as well.
   int basePulse = 200;                                            // base pulse length in microse
   int startSequence[] = { 1,1,1,1,1,1,1,1,6,6 };                  // pulse sequence for sync + RF start bit
   int Bit0[] = { 3,1 };                                           // pulse for bit 0 - currently only an array of 2 values is supported!!
   int Bit1[] = { 1,3 };                                           // pulse for bit 1 - currently only an array of 2 values is supported!!
   // int endSequence { 1,1,1,2,2,2 };				                     // appending an end-sequence for being more flexible for more complex protocols??? NOT IMPLEMENTED YET!!
   int codeSequence[64];                                           // Array of 64 values (64 high/low changes for 32 bit signal); any changes to the Bit0/Bit1 array size need to be reflected in the code sequence array size as well
   int signalRepetitions = 6;                                      // how many times the signal should be transmitted (usally 4-6 times for transmission robustness)

   // Some calculated variables
   int startSequenceSize = sizeof(startSequence) / sizeof(startSequence[0]);	//determine the amount of entries in the start sequence array
   int codeSequenceSize = sizeof(codeSequence) / sizeof(codeSequence[0]);		  //determine the amount of entries in the code sequence array
   //int Bit0Size = sizeof(Bit0) / sizeof(Bit0[0]);							              //determine the amount of entries in the Bit0 array - NOT USED IN CURRENT STATE
   //int Bit1Size = sizeof(Bit1) / sizeof(Bit1[0]);							              //determine the amount of entries in the Bit1 array - NOT USED IN CURRENT STATE


   // --- generateCode() ---
   // 'Command' (uint8_t)    = Is the command that should be transmitted to the LED driver / controller.
   // 'InputIsSlider' (bool) = TRUE is used for inputs generated by the user interface's slide. Argument is handed
	 //                          over to the transmitCode() function and controlling the signal repition.
   // The LED driver's / controller's address bytes, the 'command' byte as well as the calculated checksum byte
   // are being combined to a 32 bit word expected by the LED driver / controller and written to the code sequence
   // array (storing the signal high/low times).

   void generateCode(uint8_t command) {
     uint32_t combined = 0;
     int8_t cks_offset = 83; // checksum offset (not as unsigned in case other protocols are using negative values; TO DO: sign of the value here as well as in the checksum calculation should be inverted)
     uint8_t checksum = 0;

     checksum = (RFaddress[0] + RFaddress[1] + command - cks_offset);                                                              // generate checksum byte
     combined = ((uint32t)RFaddress[0] << 24) | ((uint32_t)RFaddress[1] << 16) | ((uint32_t)command << 8) | (uint32_t)checksum;    // combine all 4 signal bytes to a 32-bit word

     // parsing the variable 'combined' bit for bit and write the corresponding HIGH/LOW times from the Bit0- and Bit1-arrays into the codeSequence array
     int n = sizeof(combined) * 8 - 1;                  // variable n needed for counter-counting the array position to be filled, as LSB and MSB are reversed in the combined variable and the array order
     for (int i = 0; i < (sizeof(combined)*8); i++) {
       bool b = bitRead(combined, i);
       switch (b) {
         case 0:
           codeSequence[(n - i) * 2] = Bit0[0];
           codeSequence[(n - i) * 2 + 1] = Bit0[1];
           break;
         case 1:
           codeSequence[(n - i) * 2] = Bit1[0];
           codeSequence[(n - i) * 2 + 1] = Bit1[1];
           break;
       }
     }

     void transmitCode() {
       
         




